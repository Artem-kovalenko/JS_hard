// Контекст
// this - кючевое слово, которое указывает на текущий контекст
// По умолчанию this - хранит глобальный объект Window

function hello() {
	console.log('Hello', this);
}

const person = {
	name: 'Artem',
	age: 18,
	sayHello: hello
}

// this - указывает на обьект, в контексте которого он вызвал
// window.hello() === обьект window
// person.sayHello() === обьект person


// Чтобы передавать какой либо контекст и вызывать функцию с нужным контекстом 
// Можно использовать встроенные методы, которые есть у функции в JS


// .bind - передаём контекст, который будет привязан к функции
const student = {
	name: 'Artem',
	age: 18,
	sayHello: hello,
	sayHelloWindow: hello.bind(window)
	logInfo: function(job, phone) {
		console.group(`${this.name} info:`) //создадим группу
		console.log(`Name is ${this.name}`) //здесь this = обекту student, потому что создали функцию в конектсте этого обьекта
		console.log(`Age is ${this.age}`)
		console.log(`Job is ${job}`)
		console.log(`Phone is ${phone}`)
		console.groupEnd() // закрыли группу
	}
}


const lena = {
	name: 'Elena',
	age: 23
}

// ===============.bind()==================================
// Используем функцию logInfo чтоб вывести значения обьекта lena a не student

// Передаём параметры в функцию
student.logInfo.bind(lena, 'Front-end', '8-999-123-124')()

// Или вот так
const fnLenaInfoLog = student.logInfo.bind(lena)
fnLenaInfoLog('Front-end', '8-999-123-124')

// метод .bind() возвращает новую функцию но с переданным новым контекстом (lena) и можем её вызвать тогда, когда хотим
// поэтому logInfo будет спользовать не старый контекст student, а новый - lena
// Поэтому тут поставили еще одни (), чтобы сразу вызвать возвращенную функцию.


// ===============.call()==================================
//для таких же целей
// call не вызываем как функцию 
// можем передавать бесконечно параметров
// call сразу вызываёт эту функцию 
student.logInfo.call(lena, 'Front-end', '8-999-123-124')

// ===============.apply()==================================
// передаём обьект, который является контекстом
// в метод .apply всегда передаём 2 параметра, второй - массив
// метод сразу вызывает функцию
student.logInfo.apply(lena, ['Front-end', '8-999-123-124'])

// ====== Практика =====

const array = [1, 2, 3, 4, 5]
// написать функцию кторая позволит умножить каждое из значений массива на число которое мы будем передавать

function multBy(arr, n) {
	return arr.map(function(i) { //с помощью метода .map пробегаемся по массиву и на каждой итерации вызываем функцию
		return i * n 
	})
}

console.log(multBy(array, 5))
// это не самый удобный вариаент


// как сделать чтоб у массива сразу был метод для данного функционала
// используем прототипы!

const array = [1, 2, 3, 4, 5]

Array.protorype.multBy = function(n) {  // в прототипе массива создаём новую функцию используя .protorype
	return this.map(function(i) { // this указывает на тот обьект, который находится слева от точки, в нашем случае массив array
		return i * n 
	})
}    

console.log(array.multBy(2))
// теперь мы можем у любого обьекта вызвать наш созданный метод multBy(n)
// потому что мы добавили его в прототип главного обьекта
// и он нам всегда доступен

